\section{Vectorizaci'on}

En los algoritmos \ref{algo1} y \ref{algo2} se puede ver que t'ecnica se compone de varias partes, claramente divididas. Primero aparece el c'omputo de las interpolaciones. Luego tenemos la metamorfosis propiamente dicha, etapa en la que se construye cada una de las im'agenes intermedias. Para cada una de estas im'agenes, se itera sobre todos los pixeles, y se realizan dos tipos de operaciones: reverse mapping y blending.

Dado que la cantidad de segmentos $s$ suele ser peque\~{n}a, se decidi'o no vectorizar el c'omputo de las interpolaciones. El blending tampoco fue vectorizado, puesto que, suponiendo que tenemos varios p'ixeles de la imagen origen y destino que mezclar, es muy probable que no ocupen posiciones consecutivas, forzando a la realizaci'on de m'ultiples lecturas de memoria para obtener las componentes RGB de tales pixeles. Por esta raz'on, el 'unico c'omputo en paralelo posible aqu'i ser'ia la cuenta de la ecuaci'on \ref{eq_blend}. Si bien esto podr'ia significar una ganancia de tiempo, es despreciable respecto del costo en que incurrimos al realizar los accesos a memoria, por lo que decidimos no vectorizarlo.

En donde s'i exist'ia una gran posibilidad de vectorizaci'on, es en el reverse mapping, es decir, el algoritmo \ref{algo1}, que tiene dos caracter'isticas propicias. Por un lado, la independencia entre el procesamiento de distintos pixeles, puesto que c'omputo del algoritmo  para un pixel dado es independiente del c'omputo para cualquier otro pixel. Por otro lado, la casi inexistencia de branching. El 'unico momento en que debemos tomar decisiones es al calcular la distancia $d(\mathbf{x}, \mathbf{p}[i]\mathbf{q}[i])$ en la l'inea 8, aunque es posible evitar el branching computando el resultado de todas las ramas de ejecuci'on posibles, qued'andonos con el resultado de la que corresponda, a trav'es de m'ascaras de bits. Esta t'ecnica es cl'asica en el contexto de la vectorizaci'on de bloques de decisi'on, de modo que no profundizaremos en su implementaci'on.

La vectorizaci'on de este algoritmo logra computar, para una entrada de cuatro pixeles, el pixel fuente que le corresponde cada uno. La idea atr'as de esta implementaci'on es tomar todas las magnitudes computadas en el algoritmo est'andar ($u$, $v$, las coordenadas de todos los vectores involucrados, etc.), y disponer cada una en un registro XMM distinto. De esta forma, cada registro XMM contiene cuatro valores correspondientes a una misma magnitud, permitiendo el procesamiento simult'aneo de cuatro instancias del algoritmo.

Es cuatro es la cantidad de pixeles que se pueden procesar al mismo tiempo, debido a que todas las magnitudes involucradas son n'umeros de punto flotante de precisi'on simple, que tienen 4B de longitud, mientras que los registros XMM tienen 16B de longitud. Todos los c'omputos fueron realizados con representaci'on de punto flotante de dicha precisi'on.