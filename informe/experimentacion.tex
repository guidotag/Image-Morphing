\section{Experimentaci'on}

\subsection{Resultados}

Comparamos una implementaci'on en C, con la vectorizada. Para esto, tomamos dos imagenes de tama\~{n}o $1024 \times 768$, y trazamos 44 segmentos sobre cada una de ellas. En la figura \ref{fig8} se puede ver la metamorfosis utilizando los 44 segmentos.

\begin{figure}[H]
	\begin{center}
		%\includegraphics[scale=]{}
	\end{center}		
	\caption{Metamorfosis empleada para benchmarking}
	\label{fig8}
\end{figure}

Para la comparaci'on, decidimos dejar fija las im'agenes origen y destino, es decir que $w = 1024$ y $h = 768$, fijar la cantidad de frames de la metamorfosis en $f = 100$, y variar la cantidad de segmentos $s$ utilizados. Esta elecci'on se basa en que el par'ametro $s$ es el que determina la intensidad del c'omputo de cada una de las llamadas individuales a la implementaci'on del algoritmo \ref{algo1}, que es la pieza que hemos vectorizado. Los par'ametros $f$, $w$ y $h$ solamente marcan cu'antas veces se llama a ese procedimiento.

Para cada una de las implementaciones, y variando $s \in \{0, 5, 10, 15, 20, 25, 30, 35, 40\}$, medimos el tiempo de ejecuci'on total, de todo el algoritmo \ref{algo2}. Esto incluye el overhead que impone en framework utilizado para el manejo de video, para la creaci'on de un frame sobre el que trabajamos a lo largo de todo el proceso, y su escritura en el video, al finalizar cada iteraci'on. Como se puede ver en los tiempos de ejecuci'on para $s = 0$, experimento en el que s'olo escribimos sobre el video, casi sin realizar c'omputos en el algoritmo \ref{algo1}, este overhead es despreciable respecto del resto del procesamiento.

En la figura \ref{fig9} presentamos los resultados de la comparaci'on. Ambas versiones fueron compiladas con el flag de optimizaci'on -O3. Como estamos variando 'unicamente $s$, los gr'aficos de los tiempo de ejecuci'on son, como se espera,  rectas, cuya pendiente es proporcional a $f \times w \times h$.

\begin{figure}[H]
	\begin{center}
		%\includegraphics[scale=]{}
	\end{center}		
	\caption{Comparaci'on C vs. SIMD}
	\label{fig9}
\end{figure}

Una cuenta permite ver que, en promedio, la implementaci'on SIMD es 25 veces m'as r'apida que la versi'on en C, lo cual es una diferencia m'as que notable.

\subsection{An'alisis}

En general, al vectorizar procedimientos obtenemos ganancias m'ultiplo de la cantidad de datos procesados al mismo tiempo. Sin embargo, en este caso, la vectorizaci'on supera ampliamente esa expectativa, al ser 25 veces m'as r'apida, pese a que cada ejecuci'on procesa s'olo 4 pixeles en paralelo. En busca de una explicaci'on para este fen'omeno, comparamos con lupa ambas implementaciones.

La implementaci'on con extensiones SIMD tiene dos caracter'isticas remarcables, directamente relacionadas con su performance:

\begin{itemize}
	\item \textbf{Casi todas las magnitudes involucradas se mantienen, todo el tiempo, en registros.} Esto permite evitar accesos a memoria, que son hasta 100 veces m'as costosos que los accesos a registros, en el caso de un cache miss.
	\item \textbf{Todas las funciones auxiliares est'an implementadas en forma de macros.} Si bien esto permite reducir el overhead de una implementaci'on que usa etiquetas e instrucciones \texttt{call}, la motivaci'on verdadera fue hacer la programaci'on m'as sencilla, puesto que, en el intento de mantener la mayor'ia de los datos en registros, 'estos deb'ian ser manipulados cuidadosamente. Utilizando macros podemos decidir exactamente qu'e registros queremos que sean utilizados por una rutina.
\end{itemize}

Ambas elecciones tienen desventajas. Por un lado, al intentar explotar al m'aximo la utilizaci'on de los registros, se hace mucho m'as complicada la programaci'on, al ser limitada la cantidad de registros que tenemos a nuestra disposici'on. Sortear este problema es simplemente una cuesti'on de planificar bien el programa. Por otro lado, la utilizaci'on de macros tiene dos desventajas. Primero, no es posible una utilizaci'on din'amica de ese pedazo de c'odigo, en el sentido de que cada llamada a la macro replicar'a su c'odigo, haciendo que el c'odigo objeto sea mucho m'as largo. En nuestro caso, el c'odigo objeto de la vectorizaci'on consta de algunos cientos de l'ineas, de modo que, en este caso, 'esto no resulta una verdadera contra. En segundo lugar, no es posible debuggear las l'ineas que componen a la macro, haciendo m'as dif'icil la detecci'on y correcci'on de errores.

Para realizar una fiel comparaci'on contra el programa C, realizamos un dump del c'odigo objeto de esta implementaci'on. La primer observaci'on que hicimos, es que la cantidad neta de l'ineas de la versi'on C del reverse mapping y todas las funciones auxiliares utilizadas, es de 650 l'ineas aproximadamente, mientras que la versi'on SIMD tiene alrededor de 350. Si bien un programa m'as compacto no es necesariamente mejor, en este caso es tenemos 350 l'ineas que fueron cuidadosamente pensadas, contrariamente a las 650 elaboradas por un compilador, lo cual podr'ia indicar que la mano humana est'a haciendo diferencia.

En este sentido, notamos que hay auxiliares del dump de C que son sorprendentemente complejas, especialmente las funciones \texttt{add} y \texttt{subtract}, que se encargan de sumar y restar vectores respectivamente. La versi'on SIMD de \texttt{add} se compone de las siguientes dos instrucciones:

\begin{verbatim}
addps xmm0, xmm2
addps xmm1, xmm3
\end{verbatim}

\noindent
donde \texttt{xmm0} y \texttt{xmm2} contienen las coordenadas $x$ de los vectores a sumar, y \texttt{xmm1} y \texttt{xmm3} las coordenadas $y$. El c'odigo original de la versi'on C es el siguiente:

\begin{verbatim}
point add(point a, point b) {
    point res;
    res.x = a.x + b.x;
    res.y = a.y + b.y;
    return res;
}
\end{verbatim}

\noindent
mientras que su dump es:

\begin{verbatim}
movq   QWORD PTR [rsp-0x38],xmm0
mov    rdx,QWORD PTR [rsp-0x38]
movq   QWORD PTR [rsp-0x38],xmm1
mov    rax,QWORD PTR [rsp-0x38]
mov    rcx,rdx
mov    DWORD PTR [rsp-0x10],edx
shr    rcx,0x20
mov    rsi,rax
mov    DWORD PTR [rsp-0xc],eax
mov    QWORD PTR [rsp-0x38],rcx
shr    rsi,0x20
movss  xmm3,DWORD PTR [rsp-0x38]
mov    QWORD PTR [rsp-0x28],rsi
movss  xmm2,DWORD PTR [rsp-0x10]
addss  xmm3,DWORD PTR [rsp-0x28]
addss  xmm2,DWORD PTR [rsp-0xc]
movss  DWORD PTR [rsp-0x38],xmm3
mov    rdx,QWORD PTR [rsp-0x38]
movss  DWORD PTR [rsp-0x10],xmm2
mov    eax,DWORD PTR [rsp-0x10]
shl    rdx,0x20
or     rax,rdx
mov    QWORD PTR [rsp-0x38],rax
movq   xmm0,QWORD PTR [rsp-0x38]
ret    
nop    WORD PTR cs:[rax+rax*1+0x0]
\end{verbatim}